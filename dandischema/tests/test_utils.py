from contextlib import nullcontext
from typing import Dict, List, Optional, Union, cast

from jsonschema.exceptions import SchemaError, ValidationError
from jsonschema.protocols import Validator as JsonschemaValidator
from jsonschema.validators import Draft7Validator, Draft202012Validator
import pytest

from dandischema.utils import jsonschema_validator

from ..utils import (
    _ensure_newline,
    name2title,
    sanitize_value,
    strip_top_level_optional,
    version2tuple,
)


@pytest.mark.parametrize(
    "name,title",
    [
        ("relatedResource", "Related Resource"),
        ("identifier", "Identifier"),
        ("wasGeneratedBy", "Was Generated by"),
        ("sameAs", "Same as"),
        ("includeInCitation", "Include in Citation"),
        ("anExtraField", "An Extra Field"),
        ("propertyID", "Property ID"),
        ("fieldINeed", "Field I Need"),
        ("needsADatum", "Needs a Datum"),
        ("contentUrl", "Content URL"),
        ("ContactPoint", "Contact Point"),
    ],
)
def test_name2title(name: str, title: str) -> None:
    assert name2title(name) == title


@pytest.mark.parametrize(
    "ver,error",
    [
        ("ContactPoint", True),
        ("0.1.2", False),
        ("0.12.20", False),
        ("0.1.2a", True),
        ("0.1.2-rc1", True),
    ],
)
def test_version(ver: str, error: bool) -> None:
    if error:
        with pytest.raises(ValueError):
            version2tuple(ver)
    else:
        assert len(version2tuple(ver)) == 3


def test_newline() -> None:
    obj = "\n"
    assert _ensure_newline(obj).endswith("\n")
    obj = ""
    assert _ensure_newline(obj).endswith("\n")


@pytest.mark.parametrize(
    "input_, expected_output",
    [
        (Union[str, int, None], Union[str, int, None]),
        (Optional[Union[str, int]], Optional[Union[str, int]]),
        (Union[int], Union[int]),
        (Union[None], Union[None]),
        (Union[str, int, None, None], Union[str, int, None, None]),
        (Union[None, int, str], Union[None, int, str]),
        (Union[None, int, None, str], Union[None, int, None, str]),
        (Optional[str], str),
        (Optional[Optional[str]], str),
        (Optional[List[Optional[str]]], List[Optional[str]]),
        (Union[None, int], int),
        (Union[None, int, None], int),
        (Union[None, Dict[str, int]], Dict[str, int]),
        (int, int),
        (float, float),
    ],
)
def test_strip_top_level_optional(input_: type, expected_output: type) -> None:
    assert strip_top_level_optional(input_) == expected_output


def test_sanitize_value() -> None:
    # . is not sanitized in extension but elsewhere
    assert sanitize_value("_.ext", "extension") == "-.ext"
    assert sanitize_value("_.ext", "unrelated") == "--ext"
    assert sanitize_value("_.ext") == "--ext"
    assert sanitize_value("A;B") == "A-B"
    assert sanitize_value("A\\/B") == "A--B"
    assert sanitize_value("A\"'B") == "A--B"


@pytest.fixture
def draft7_schema() -> dict:
    """
    A minimal valid Draft 7 schema requiring a 'name' property of type 'string'.
    """
    return {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "type": "object",
        "properties": {"name": {"type": "string"}},
        "required": ["name"],
    }


@pytest.fixture
def draft202012_schema() -> dict:
    """
    A minimal valid Draft 2020-12 schema requiring a 'title' property of type 'string'.
    """
    return {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {"title": {"type": "string"}},
        "required": ["title"],
    }


@pytest.fixture
def draft202012_format_schema() -> dict:
    """
    Draft 2020-12 schema that includes a 'format' requirement (e.g., 'email').
    Used to test the 'check_format' parameter.
    """
    return {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {"email": {"type": "string", "format": "email"}},
        "required": ["email"],
    }


@pytest.fixture
def schema_no_dollar_schema() -> dict:
    """
    Schema that lacks the '$schema' property altogether.
    Used to test that 'default_cls' is applied.
    """
    return {
        "type": "object",
        "properties": {"foo": {"type": "string"}},
        "required": ["foo"],
    }


class TestJsonschemaValidator:
    @pytest.mark.parametrize(
        ("fixture_name", "expected_validator_cls"),
        [
            pytest.param(
                "draft202012_format_schema", Draft202012Validator, id="Draft202012"
            ),
            pytest.param("draft7_schema", Draft7Validator, id="Draft7"),
        ],
    )
    @pytest.mark.parametrize("check_format", [True, False])
    def test_set_by_dollar_schema(
        self,
        request: pytest.FixtureRequest,
        fixture_name: str,
        expected_validator_cls: type,
        check_format: bool,
    ) -> None:
        """
        Test that the correct validator class is returned for different '$schema' values
        """
        # Dynamically retrieve the appropriate fixture schema based on fixture_name
        schema = request.getfixturevalue(fixture_name)

        validator = jsonschema_validator(schema, check_format=check_format)

        assert isinstance(validator, expected_validator_cls)

    @pytest.mark.parametrize(
        ("check_format", "instance", "expect_raises"),
        [
            (True, {"email": "test@example.com"}, False),
            (True, {"email": "not-an-email"}, True),
            (False, {"email": "not-an-email"}, False),
        ],
        ids=[
            "check_format=True, valid email",
            "check_format=True, invalid email",
            "check_format=False, invalid email",
        ],
    )
    def test_check_format_email_scenarios(
        self,
        draft202012_format_schema: dict,
        check_format: bool,
        instance: dict,
        expect_raises: bool,
    ) -> None:
        """
        Parametrized test for check_format usage on valid/invalid email addresses under
        Draft202012Validator.
        """
        validator = jsonschema_validator(
            draft202012_format_schema, check_format=check_format
        )

        # If expect_raises is True, we use pytest.raises(ValidationError)
        # Otherwise, we enter a no-op context
        ctx = pytest.raises(ValidationError) if expect_raises else nullcontext()

        with ctx:
            validator.validate(instance)  # Should raise or not raise as parametrized

    @pytest.mark.parametrize(
        ("schema_fixture", "expected_validator_cls"),
        [
            # Scenario 1: no $schema => we expect the default_cls=Draft7Validator is used
            pytest.param("schema_no_dollar_schema", Draft7Validator, id="no-$schema"),
            # Scenario 2: has $schema => draft 2020-12 overrides the default_cls
            pytest.param("draft202012_schema", Draft202012Validator, id="with-$schema"),
        ],
    )
    def test_default_cls(
        self,
        request: pytest.FixtureRequest,
        schema_fixture: str,
        expected_validator_cls: type,
    ) -> None:
        """
        If the schema has no '$schema' property, and we provide a 'default_cls',
        the returned validator should be an instance of that class.

        If the schema *does* have '$schema', then the default_cls is ignored, and
        the validator class is inferred from the schema's '$schema' field.
        """
        # Dynamically grab whichever fixture is specified by schema_fixture:
        schema = request.getfixturevalue(schema_fixture)

        # Provide default_cls=Draft7Validator
        validator = jsonschema_validator(
            schema,
            check_format=False,
            default_cls=cast(type[JsonschemaValidator], Draft7Validator),
        )
        assert isinstance(validator, expected_validator_cls)

    def test_invalid_schema_raises_schema_error(self) -> None:
        """
        Provide an invalid schema, ensuring that 'SchemaError' is raised.
        """
        invalid_schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "type": 123,  # 'type' must be string/array, so this is invalid
        }
        with pytest.raises(SchemaError):
            jsonschema_validator(invalid_schema, check_format=False)
