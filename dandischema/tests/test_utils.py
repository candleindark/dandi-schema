from contextlib import nullcontext
from copy import deepcopy
from typing import Any, Dict, List, Optional, Union, cast

from jsonschema.exceptions import SchemaError, ValidationError
from jsonschema.protocols import Validator as JsonschemaValidator
from jsonschema.validators import Draft7Validator, Draft202012Validator
import pytest

from dandischema.exceptions import JsonschemaValidationError
from dandischema.utils import (
    _ensure_newline,
    jsonschema_validator,
    name2title,
    sanitize_value,
    strip_top_level_optional,
    validate_json,
    version2tuple,
)


@pytest.mark.parametrize(
    "name,title",
    [
        ("relatedResource", "Related Resource"),
        ("identifier", "Identifier"),
        ("wasGeneratedBy", "Was Generated by"),
        ("sameAs", "Same as"),
        ("includeInCitation", "Include in Citation"),
        ("anExtraField", "An Extra Field"),
        ("propertyID", "Property ID"),
        ("fieldINeed", "Field I Need"),
        ("needsADatum", "Needs a Datum"),
        ("contentUrl", "Content URL"),
        ("ContactPoint", "Contact Point"),
    ],
)
def test_name2title(name: str, title: str) -> None:
    assert name2title(name) == title


@pytest.mark.parametrize(
    "ver,error",
    [
        ("ContactPoint", True),
        ("0.1.2", False),
        ("0.12.20", False),
        ("0.1.2a", True),
        ("0.1.2-rc1", True),
    ],
)
def test_version(ver: str, error: bool) -> None:
    if error:
        with pytest.raises(ValueError):
            version2tuple(ver)
    else:
        assert len(version2tuple(ver)) == 3


def test_newline() -> None:
    obj = "\n"
    assert _ensure_newline(obj).endswith("\n")
    obj = ""
    assert _ensure_newline(obj).endswith("\n")


@pytest.mark.parametrize(
    "input_, expected_output",
    [
        (Union[str, int, None], Union[str, int, None]),
        (Optional[Union[str, int]], Optional[Union[str, int]]),
        (Union[int], Union[int]),
        (Union[None], Union[None]),
        (Union[str, int, None, None], Union[str, int, None, None]),
        (Union[None, int, str], Union[None, int, str]),
        (Union[None, int, None, str], Union[None, int, None, str]),
        (Optional[str], str),
        (Optional[Optional[str]], str),
        (Optional[List[Optional[str]]], List[Optional[str]]),
        (Union[None, int], int),
        (Union[None, int, None], int),
        (Union[None, Dict[str, int]], Dict[str, int]),
        (int, int),
        (float, float),
    ],
)
def test_strip_top_level_optional(input_: type, expected_output: type) -> None:
    assert strip_top_level_optional(input_) == expected_output


def test_sanitize_value() -> None:
    # . is not sanitized in extension but elsewhere
    assert sanitize_value("_.ext", "extension") == "-.ext"
    assert sanitize_value("_.ext", "unrelated") == "--ext"
    assert sanitize_value("_.ext") == "--ext"
    assert sanitize_value("A;B") == "A-B"
    assert sanitize_value("A\\/B") == "A--B"
    assert sanitize_value("A\"'B") == "A--B"


@pytest.fixture
def draft7_schema() -> dict:
    """
    A minimal valid Draft 7 schema requiring a 'name' property of type 'string'.
    """
    return {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "type": "object",
        "properties": {"name": {"type": "string"}},
        "required": ["name"],
    }


@pytest.fixture
def draft202012_schema() -> dict:
    """
    A minimal valid Draft 2020-12 schema requiring a 'title' property of type 'string'.
    """
    return {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {"title": {"type": "string"}},
        "required": ["title"],
    }


@pytest.fixture
def draft202012_format_schema() -> dict:
    """
    Draft 2020-12 schema that includes a 'format' requirement (e.g., 'email').
    Used to test the 'check_format' parameter.
    """
    return {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {"email": {"type": "string", "format": "email"}},
        "required": ["email"],
    }


@pytest.fixture
def schema_no_dollar_schema() -> dict:
    """
    Schema that lacks the '$schema' property altogether.
    Used to test that 'default_cls' is applied.
    """
    return {
        "type": "object",
        "properties": {"foo": {"type": "string"}},
        "required": ["foo"],
    }


class TestJsonschemaValidator:
    @pytest.mark.parametrize(
        ("fixture_name", "expected_validator_cls"),
        [
            pytest.param(
                "draft202012_format_schema", Draft202012Validator, id="Draft202012"
            ),
            pytest.param("draft7_schema", Draft7Validator, id="Draft7"),
        ],
    )
    @pytest.mark.parametrize("check_format", [True, False])
    def test_set_by_dollar_schema(
        self,
        request: pytest.FixtureRequest,
        fixture_name: str,
        expected_validator_cls: type,
        check_format: bool,
    ) -> None:
        """
        Test that the correct validator class is returned for different '$schema' values
        """
        # Dynamically retrieve the appropriate fixture schema based on fixture_name
        schema = request.getfixturevalue(fixture_name)

        validator = jsonschema_validator(schema, check_format=check_format)

        assert isinstance(validator, expected_validator_cls)

    @pytest.mark.parametrize(
        ("check_format", "instance", "expect_raises"),
        [
            (True, {"email": "test@example.com"}, False),
            (True, {"email": "not-an-email"}, True),
            (False, {"email": "not-an-email"}, False),
        ],
        ids=[
            "check_format=True, valid email",
            "check_format=True, invalid email",
            "check_format=False, invalid email",
        ],
    )
    def test_check_format_email_scenarios(
        self,
        draft202012_format_schema: dict,
        check_format: bool,
        instance: dict,
        expect_raises: bool,
    ) -> None:
        """
        Parametrized test for check_format usage on valid/invalid email addresses under
        Draft202012Validator.
        """
        validator = jsonschema_validator(
            draft202012_format_schema, check_format=check_format
        )

        # If expect_raises is True, we use pytest.raises(ValidationError)
        # Otherwise, we enter a no-op context
        ctx = pytest.raises(ValidationError) if expect_raises else nullcontext()

        with ctx:
            validator.validate(instance)  # Should raise or not raise as parametrized

    @pytest.mark.parametrize(
        ("schema_fixture", "expected_validator_cls"),
        [
            # Scenario 1: no $schema => we expect the default_cls=Draft7Validator is used
            pytest.param("schema_no_dollar_schema", Draft7Validator, id="no-$schema"),
            # Scenario 2: has $schema => draft 2020-12 overrides the default_cls
            pytest.param("draft202012_schema", Draft202012Validator, id="with-$schema"),
        ],
    )
    def test_default_cls(
        self,
        request: pytest.FixtureRequest,
        schema_fixture: str,
        expected_validator_cls: type,
    ) -> None:
        """
        If the schema has no '$schema' property, and we provide a 'default_cls',
        the returned validator should be an instance of that class.

        If the schema *does* have '$schema', then the default_cls is ignored, and
        the validator class is inferred from the schema's '$schema' field.
        """
        # Dynamically grab whichever fixture is specified by schema_fixture:
        schema = request.getfixturevalue(schema_fixture)

        # Provide default_cls=Draft7Validator
        validator = jsonschema_validator(
            schema,
            check_format=False,
            default_cls=cast(type[JsonschemaValidator], Draft7Validator),
        )
        assert isinstance(validator, expected_validator_cls)

    def test_invalid_schema_raises_schema_error(self) -> None:
        """
        Provide an invalid schema, ensuring that 'SchemaError' is raised.
        """
        invalid_schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "type": 123,  # 'type' must be string/array, so this is invalid
        }
        with pytest.raises(SchemaError):
            jsonschema_validator(invalid_schema, check_format=False)


# --------------------------------------------------------------------
# FIXTURES that build on top of existing schema fixtures
# --------------------------------------------------------------------
@pytest.fixture
def draft7_schema_with_version(draft7_schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Copies the existing Draft 7 fixture and adds a "schemaVersion" property.
    """
    schema = deepcopy(draft7_schema)
    schema["properties"]["schemaVersion"] = {
        "type": "string",
        "default": "0.6.1",
    }
    return schema


@pytest.fixture
def draft202012_schema_with_version(
    draft202012_schema: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Copies the existing Draft 2020-12 fixture and adds a "schemaVersion" property.
    """
    schema = deepcopy(draft202012_schema)
    schema["properties"]["schemaVersion"] = {
        "type": "string",
        "default": "0.6.9",
    }
    return schema


# --------------------------------------------------------------------
# TEST CLASS for validate_json
# --------------------------------------------------------------------
class TestValidateJson:
    @pytest.mark.parametrize(
        "schema_fixture",
        [
            # Fixtures without the 'schemaVersion' property,
            "draft7_schema",
            "draft202012_schema",
            "draft202012_format_schema",
            "schema_no_dollar_schema",
        ],
        ids=[
            "draft7_schema_no_schemaVersion",
            "draft202012_schema_no_schemaVersion",
            "draft202012_format_schema_no_schemaVersion",
            "schema_no_dollar_schema_no_schemaVersion",
        ],
    )
    def test_missing_schema_version(
        self, request: pytest.FixtureRequest, schema_fixture: str
    ) -> None:
        """
        Test that a ValueError is raised if the schema lacks a "schemaVersion" property
        that specifies the version of DANDI JSON schema
        """
        # Retrieve the fixture by name
        fixture_schema = request.getfixturevalue(schema_fixture)

        schema = fixture_schema
        with pytest.raises(ValueError):
            validate_json({}, schema)

        # Test schema without 'properties' key
        schema = deepcopy(fixture_schema).pop("properties")
        with pytest.raises(ValueError):
            validate_json({}, schema)

        # Test schema without a "default" field in the "schemaVersion" property
        schema = deepcopy(fixture_schema)
        schema["properties"]["schemaVersion"] = {"type": "string"}  # Missing 'default'
        with pytest.raises(ValueError):
            validate_json({}, schema)

    @pytest.mark.parametrize(
        "schema_fixture",
        [
            # We pass a fixture with a valid "schemaVersion" property,
            # but we break the schema definition
            pytest.param("draft7_schema_with_version", id="draft7_schema_invalid"),
            pytest.param(
                "draft202012_schema_with_version", id="draft202012_schema_invalid"
            ),
        ],
    )
    def test_invalid_schema(
        self, request: pytest.FixtureRequest, schema_fixture: str
    ) -> None:
        """
        Test that a SchemaError is raised if the schema is invalid.
        We intentionally corrupt the "type" field to a non-string value.
        """
        schema = request.getfixturevalue(schema_fixture)
        schema["type"] = 123  # Invalid: 'type' must be a string or array in JSON Schema

        with pytest.raises(SchemaError):
            validate_json({}, schema)

    @pytest.mark.parametrize(
        ("schema_fixture", "instance"),
        [
            pytest.param(
                "draft7_schema_with_version",
                {"name": "Alice"},
                id="draft7_schema_valid_instance",
            ),
            pytest.param(
                "draft202012_schema_with_version",
                {"title": "My Title"},
                id="draft202012_schema_valid_instance",
            ),
        ],
    )
    def test_valid_instance(
        self,
        request: pytest.FixtureRequest,
        schema_fixture: str,
        instance: Dict[str, Any],
    ) -> None:
        """
        Test that a valid instance does not raise any exceptions.
        """
        schema = request.getfixturevalue(schema_fixture)
        validate_json(instance, schema)  # No exception expected

    @pytest.mark.parametrize(
        ("schema_fixture", "instance"),
        [
            pytest.param(
                "draft7_schema_with_version",
                {},  # Missing required "name"
                id="draft7_schema_missing_name",
            ),
            pytest.param(
                "draft7_schema_with_version",
                {"name": 123},  # Wrong type
                id="draft7_schema_wrong_type_for_name",
            ),
            pytest.param(
                "draft202012_schema_with_version",
                {},  # Missing required "title"
                id="draft202012_schema_missing_title",
            ),
            pytest.param(
                "draft202012_schema_with_version",
                {"title": 999},  # Wrong type
                id="draft202012_schema_wrong_type_for_title",
            ),
        ],
    )
    def test_invalid_instance(
        self,
        request: pytest.FixtureRequest,
        schema_fixture: str,
        instance: Dict[str, Any],
    ) -> None:
        """
        Test that an invalid instance raises a JsonschemaValidationError.
        Also assert that the raised error contains a non-empty list of
        `jsonschema.exceptions.ValidationError` objects.
        """
        schema = request.getfixturevalue(schema_fixture)

        with pytest.raises(JsonschemaValidationError) as exc_info:
            validate_json(instance, schema)

        # Ensure that the exception has a non-empty list of validation errors
        errs = exc_info.value.errors
        assert type(errs) is list, "Expected a list"
        assert len(errs) > 0, "Expected at least one error"
        assert all(
            isinstance(err, ValidationError) for err in errs
        ), "All errors must be `jsonschema.exceptions.ValidationError`"
